Here are some example configs for how I see one should properly provide both non-JR and optional JR configs.
The goal is to keep the classes less cluttered and avoid having same attachment proxies used more than once (possibly what's leading to game crashes).

VANILLA CONFIG
Code:

class CfgPatches {
	class MY_WEAPON {
		requiredaddons[] = {"A3_Weapons_F"};
	};
};

class CfgWeapons {
	class Rifle_Base_F;
	
	class Rifle_Long_Base_F : Rifle_Base_F {
		class WeaponSlotsInfo;
	};
	
	class EBR_base_F : Rifle_Long_Base_F {
		class WeaponSlotsInfo : WeaponSlotsInfo {
			class MuzzleSlot;
			class CowsSlot;
			class PointerSlot;
		};
	};

	// non-JR base class
	class MY_WEAPON_BASE : EBR_base_F {
		class WeaponSlotsInfo : WeaponSlotsInfo {
			class MuzzleSlot : MuzzleSlot {
				compatibleItems[] += {"MY_MUZZLE"};
			};
			class CowsSlot : CowsSlot {
				compatibleItems[] += {"MY_SIGHT"};
			};
			class PointerSlot : PointerSlot {
				compatibleItems[] += {"MY_FLASHLIGHT"};
			};
		};
	};

	// reserved base class for alternative optional slot configs
	class MY_WEAPON_BASE_2 : MY_WEAPON_BASE {
		class WeaponSlotsInfo : WeaponSlotsInfo {};
	};

	// this is my cool new weapon
	class MY_WEAPON : MY_WEAPON_BASE_2 {
		scope = 2;
	};
};

OPTIONAL JR CONFIG
Code:

class CfgPatches {
	class MY_WEAPON_JR {
		requiredaddons[] = {"A3_Weapons_F", "MY_WEAPON", "asdg_jointrails"};
	};
};

class asdg_SlotInfo;

class asdg_FrontSideRail : asdg_SlotInfo {
	class compatibleItems {
		MY_FLASHLIGHT = 1;
	};
};

class asdg_OpticRail;

class asdg_OpticRail1913: asdg_OpticRail {
	class compatibleItems {
		MY_SIGHT = 1;
	};
};

class CfgWeapons {
	class MY_WEAPON_BASE : EBR_base_F {
		class WeaponSlotsInfo;
	};

	// add JR support here
	class MY_WEAPON_BASE_2 : MY_WEAPON_BASE {
		class WeaponSlotsInfo : WeaponSlotsInfo {
			class CowsSlot : asdg_OpticRail1913 {};
			class PointerSlot : asdg_FrontSideRail {};
		};
	};
};


And following that model, this is how I should have implemented the EBR JR slots:

Code:

	class EBR_base_F: Rifle_Long_Base_F {
		class WeaponSlotsInfo;
	};
	class srifle_EBR_F : EBR_base_F {
		class WeaponSlotsInfo: WeaponSlotsInfo {
			class PointerSlot: asdg_FrontSideRail {};
			class CowsSlot: asdg_OpticRail1913 {};
		};
	};

Will do it in a future update. The reason I didn't so far was to account to not so well scripted gear scripts that considered those default slot class names use compatibleItems[] arrays and not checking if maybe they use a compatibleItems{} class instead. 